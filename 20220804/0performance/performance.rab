= プログラムの計算量と実行性能について

: author
   結城洋志
: institution
   株式会社クリアコード
: content-source
   リーダブルコード演習
: date
   2022-08-04
: allotted-time
   90m
: theme
   clear-code

= 講師紹介

(('tag:center'))(('tag:margin-bottom * 2'))
結城洋志（ゆうき ひろし）\n
aka Piro

  * 株式会社クリアコード所属
  * FirefoxやThunderbirdの\n
    法人サポートに従事
    * トラブルの原因や対策を探るため\n
      ソースコードを調査することが多い

== ノート

Mozilla FirefoxはWebブラウザー。
Mozilla Thunderbirdはメールクライアント。

開発元のMozillaは、企業ユーザーからのトラブル問い合わせなどに回答するサービスは提供していない。
そのため、クリアコードのような事業者が、ある意味で勝手にサポートサービスを行っている。

Firefoxで特定のサービスの動作が遅い、といった問い合わせを受ける


= アジェンダ

  * プログラムの実行性能に\n
    影響する要素について
  * 計算量について
  * 実際にやってみる


= プログラムは「軽い」「速い」方がいい

= 「軽い」「速い」とは？

* ((*目的が素早く達成される*))\n
  例：データ変換プログラム
  * 同じ時間で多くの件数のデータを\n
    変換できる
  * データを1件変換する所要時間が短い

= 性能の指標と測定方法

* 他の方の講義で詳しく\n
  扱われるそうなので\n
  割愛

= 性能に影響する要素

* 外部要因
  * 通信待ち
  * ディスクアクセス待ち\n
    (('note:など'))
* 内部要因
  * ((*計算量*))

= 計算量

実行される処理の\n
((*回数の大小*))

= 例

「データを10件取得する」

= 1件ずつ取得する

    SELECT * FROM table OFFSET 0 LIMIT 1;
    SELECT * FROM table OFFSET 1 LIMIT 1;
    ...                         
    SELECT * FROM table OFFSET 8 LIMIT 1;
    SELECT * FROM table OFFSET 9 LIMIT 1;

→処理の実行回数は((*10回*))

= 10件まとめて取得する

    SELECT * FROM table OFFSET 0 LIMIT 10;

→処理の実行回数は((*1回*))


= 計算量はアルゴリズムで決まる

* アルゴリズム＝計算(処理)方法
  * ((*より少ない計算量*))で同じ結果を\n
    得られる\n
    ＝より優秀なアルゴリズム
  * データの件数の増加度合いに対して\n
    ((*計算量の増加度合いが小さい*))\n
    ＝より優秀なアルゴリズム

= 計算量の表し方

* Ο記法（オーダー）
  * O(1)
  * O(N)
  * O(N^2)
  * O(N!)
  * O(logN)

= O(1)：定数時間

    // 色の名前とカラーコードのデータ（ハッシュ構造）
    const COLOR_CODES = {
      blue:   0x0000FF,
      green:  0x00FF00,
      red:    0xFF0000,
      yellow: 0xFFFF00,
    };
    // 色の名前でカラーコードを特定する
    let color = COLOR_CODES['red'];
    console.log(color); // => 0xFF0000

== ノート

データ件数にかかわらず一定の速度で結果が出る。
最速のアルゴリズム。

= O(1)：定数時間

  # image
  # src = images/graph-O1.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

= O(N)：線形関数

    // 色の名前とカラーコードのデータ（配列構造）
    const COLOR_CODES = [
      { name: 'blue',   code: 0x0000FF },
      { name: 'green',  code: 0x00FF00 },
      { name: 'red',    code: 0xFF0000 },
      { name: 'yellow', code: 0xFFFF00 },
    ];
    // 色の名前でカラーコードを特定する
    let color;
    for (const item of COLOR_CODES) {
      if (item.name == 'red') {
        color = item.code;
        break;
      }
    }
    console.log(color); // => 0xFF0000

== ノート

計算量がデータ件数に正比例する。
（最悪の場合は全データを1回ずつ処理するため。）

= O(N)：線形関数

  # image
  # src = images/graph-ON.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

= O(N^2)：二乗時間

    // 重複を含む配列
    const duplicated = [
      0,1,2,3,2,1,4,3,4,5,6,7,5,6,4,8,9,5,3,2
    ];
    // 重複を取り除いた配列
    const unique = [];
    for (const duplicatedElem of duplicated) {
      let included = false;
      for (const uniqueElem of unique) {
        if (uniqueElem == duplicatedElem) {
          included = true;
          break;
        }
      }
      if (!included)
        unique.push(duplicatedElem);
    }
    console.log(unique); // => [0,1,2,3,4,5,6,7,8,9]

== ノート

データ件数の増加に対し、計算量の増加がいわゆる指数関数的な増加を見せる。
パスワードの総当たりの場合、O(n^文字数)となる。

= O(N^2)：二乗時間

  # image
  # src = images/graph-ON2.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false


= O(logN)：対数

    // 検索対象の配列（ソート済み）
    const values = [0, 3, 6, 9, 12, 70, 102];
    // 特定の値が何番目にあるかを二分探索で調べる
    const target = 12;
    let index = -1;
    let minIndex = 0;
    let maxIndex = values.length - 1;
    while (minIndex <= maxIndex) {
      let middleIndex = Math.floor((minIndex + maxIndex) / 2);
      if (values[middleIndex] == target) {
          index = middleIndex;
          break;
      }
      else if (values[middleIndex] < target)
        minIndex = middleIndex + 1;
      else
        maxIndex = middleIndex - 1;
    }
    console.log(index); // => 4

== ノート

コードは https://tech-blog.s-yoshiki.com/entry/195 の物を加工して掲載した。
データ件数の増加割合に対して計算量の増加割合が少ない。
データ件数の増加に対して、計算量の増加が緩やか。

= O(logN)：対数

  # image
  # src = images/graph-OlogN.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false


= O(N!)：階乗関数(1/3)

巡回セールスマン問題

    const cities = {
      tokyo:    { osaka: 2, hokkaido: 3, okinawa: 4,  kagawa: 5   },
      osaka:    { tokyo: 2, hokkaido: 5, okinawa: 3,  kagawa: 1   },
      hokkaido: { tokyo: 3, osaka: 5,    okinawa: 7,  kagawa: 6   },
      okinawa:  { tokyo: 4, osaka: 3,    hokkaido: 7, kagawa: 8   },
      kagawa:   { tokyo: 5, osaka: 1,    okinawa: 8,  hokkaido: 6 },
    };

== ノート

各都市と、各都市間の移動に要する時間。
ここから、移動時間が最短になる巡回ルートを求めたい。
こういう計算を「巡回セールスマン問題」と呼ぶ。

= O(N!)：階乗関数(2/3)

    function getPermutations(array) {
      const permutations = [];
      const nextPermutation = [];
      function permutate(array) {
        if (array.length === 0)
          permutations.push(nextPermutation.slice());
        for (let i = 0; i < array.length; i++) {
          array.push(array.shift());
          nextPermutation.push(array[0]);
          permutate(array.slice(1));
          nextPermutation.pop();
        }
      }
      permutate(array);
      return permutations;
    }

== ノート

組み合わせを列挙する関数。
Original version is: get-permutations npm module made by Jan Järfalk
Licensed: ISC
https://github.com/janjarfalk/get-permutations

= O(N!)：階乗関数(3/3)

    const results = [];
    for (const start of Object.keys(cities)) {
      const patterns = getPermutations(
        Object.keys(cities).filter(dest => dest != start)
      );
      for (const pattern of patterns) {
        let last;
        let total = 0;
        const route = [start, ...pattern, start];
        for (const current of route) {
          if (last)
            total += cities[last][current];
          last = current;
        }
        results.push({ route: route.join('-'), total });
      }
    }
    console.log(results.length);
    // => 120
    results.sort((a, b) => a.total - b.total);
    console.log(results[0]);
    // => { route: "tokyo-hokkaido-kagawa-osaka-okinawa-tokyo", total: 17 }

== ノート

愚直にやると、データ件数の階乗回の計算が必要になる。
ここでは、件数5で120回ループが回る。

= O(N!)：階乗関数

  # image
  # src = images/graph-ONfactorial.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

== ノート

データ件数	計算量
1	1
2	2
3	6
4	24
5	120
6	720
7	5,040
8	40,320


= アルゴリズムは処理対象のデータ構造に影響される

* データ構造によっては、\n
  アルゴリズムでの高速化には限度がある
  * より高速なアルゴリズムを使えるように、\n
    データの構造を変えてしまう方が良い場合もある
    * いわゆる前加工


== ノート



* 計算量の考え方と、よく登場する計算量の例（
  https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%83%80%E3%82%A6%E3%81%AE%E8%A8%98%E5%8F%B7#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC
 などで挙がっている物の一部を紹介）
* 基本的なパフォーマンス改善手法
  * アルゴリズムの改善
  * キャッシュの採用とそのデメリット
  * 非同期化（スレッド）
  * オーバーヘッドの削減
    * クエリを1つにまとめて発行回数を減らす、など


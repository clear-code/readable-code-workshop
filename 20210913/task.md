# 課題

この講座で開発するプログラムについて説明します。

## 概要

開発するプログラムは「辞書管理プログラム」です。

この講座の目的は「再利用性・メンテナンス性の高いコードを日常的に書く上での基礎となる考え方を身に付ける」ことです。

目的を達成するために、課題を通じて

  * リーダブルコードを発見できるようになること
  * リーダブルの基準を共有すること

を目指しますが、

  * リーダブルコードのテクニックをたくさん覚えること
  * 難しいプログラムでも実装できるようになること
  * 速く実装できるようになること
  * 他の人より優れたプログラムを実装すること
  * 奇抜な視点でプログラムを実装して注目を集めること

は目指すことではありません。
（そちらに逸れてしまって目的が達成されないのでは、本末転倒です。）

以上のことを踏まえ、次の点に注意して開発するプログラムの仕様を用意しました。

  * 言語の基本的な機能のみで実現できる。
    * ライブラリーを知っていることや使えることは重要ではない。
  * 難しいロジックを必要としない。
    * 効率のよいアルゴリズムを考えることは重要ではない。
  * 段階的に改良していく。
    * 書き捨てのプログラムではなく継続的に開発するプログラムであることは重要である。
  * すべての仕様を実装しなくてもよい。
    * 今回の実装時間は想定では180分で、仕様は13個ある。平均して13分で1つ実装するとすべての仕様を実装できるが、「速く実装できるようになること」は目的ではないので、すべての仕様を実装することは重要ではない。

開発するコードは「今の自分達で最高にリーダブルなコード」にしてください。そのとき、「どうしてこのコードはリーダブルと言えるのか」の理由も考えてください。例えば、「 `do_something` では"何か"をするのはわかるけど"何を"するのかわからない。 `open_file` ならファイルを開くということがすぐわかるのでリーダブルだ」といった具合です。

理由を考えるのは、理由をつけられるくらい考えていれば応用が効くからです。前述の例の理由からは「何をするのかわかる名前がよい」という基準を見つけられます。この基準を使えば、違うコードでもリーダブルなコードを書けます。

### リーダブルコードを書くヒント

1つ、リーダブルコードを書くためのヒントを伝えます。それは、「読む人の視点を持ちながら書くこと」です。

リーダブルコードとはどのようなコードだと思いますか？読む人がリーダブルだと思ったら、それはその人にとってリーダブルコードです。読む人にとって前提知識が違うので、より多くの人がリーダブルだと思うコードもありますし、同じ開発チームの人たちだけがリーダブルだと思うコードもあります。どちらを選ぶかは「読む人」をどのように設定したかに依存します。必ずしも「より多くの人」を選ぶことが妥当なわけではありません。例えば…、と書き始めるとヒントではなくなってしまいますね。ここで止めておくことにします。

書く時は「どんな人が読むコードか」を意識してみてください。それが、読む人の視点を持つことにつながります。

## 進め方

プログラムを1から開発します。後述する仕様を実現するようにプログラムを開発します。仕様は複数の段階があり、仕様1を実装したら、そのプログラムを改良して仕様2を実装する、というように、同じプログラムを改良しながら仕様を実現していきます。最終的には、1から12までのすべての仕様を満たす単一のプログラムと、仕様13を満たすもう1つのプログラムができあがるという想定です。

すべての仕様をいかに速く実装するか、ということは目的では **ありません** 。「リーダブルコードを発見できるようになること」が目的です。「1番速く実装したけどリーダブルコードはなにも発見できなかった」というケースは、この講座では失敗ケースです。目的を見失わないようにしましょう。

1つ仕様を実装する毎にGitHubにcommit + pushしてください。

例：

  * 仕様1を実装
  * commit + push
  * プログラムを改良して仕様2を実装
  * commit + push
  * プログラムをさらに改良して仕様3を実装
  * commit + push
  * ...

仕様を実装した状態でcommit + pushしていれば、1つの仕様を実装する間に何回commit/pushしても構いません。

例:

  * 仕様1を実装開始
  * 仕様1を30%実装
  * commit
  * 仕様1を60%実装
  * commit + push
  * 仕様1を90%実装
  * commit
  * 仕様1を100%実装
  * commit + push
  * ...

コミットメッセージにはどの仕様を実装しているかがわかるマークを入れてください。具体的には、コミットメッセージの最初に `spec${仕様番号}: ` と入れてください。

仕様1を実装しているときのコミット例:

    % git commit -m "spec1: add a sample script"
    % git commit -m "spec1: 並び替え機能を追加"

仕様3を実装しているときのコミット例:

    % git commit -m "spec3: fix a typo"
    % git commit -m "spec3: 異常値のときのテストを追加"

これは、どの仕様を実装しているかをわかりやすくするためです。後からこのコードやコミットログを「読む人」がいるということを思い出してください。

## 仕様

それぞれの仕様には次の2点を明記しています。仕様を実装した後は、各自、これらを使って仕様を満たしているかどうかを確認してください。不安な場合はチューターに質問したり、確認をお願いしてください。

  * 入力
  * 期待する結果

なお、各仕様の実現例や実行例は、仕様を最低限満たす実装の例に基づいています。仕様から逸脱していなければ、例と全く同じに実装する必要はありません。

### 仕様1：単語情報を出力できること

単語情報の見出し語として「上手」と出力するプログラムを新しく作ってください。

見出し語の出力先は問いません。コンソールに出力しても構いませんし、ファイルに出力しても、ウィンドウを作ってそこに出力しても、Webブラウザーに表示させても構いません。

#### 入力

なし

#### 期待する結果

 * プログラムが実行されたら、なんらかの形で「上手」と出力する。

#### 実現例

dictionary.sh：

    #!/bin/sh

    echo "上手"

実行：

    % chmod +x dictionary.sh
    % ./dictionary.sh
    上手

#### 実現後

仕様1を実現したらチューターに声をかけて結果を確認してもらってください。仕様1は練習です。仕様1でうまくできていたら仕様2以降もうまくやれるはずです。

### 仕様2：同じグループの他の人がプログラムを実行できること

同じグループの人があなたが書いたプログラムを実行できるように、実行手順を書いたREADME.txtを用意してください。

#### 入力

なし

#### 期待する結果

 * グループの他の人がREADME.txtに書かれた手順に従って操作して、このプログラムが仕様1を満たしていることを確認できる。

### 仕様3：単語データが別ファイルに分離されていること

今はプログラム中に「上手」の単語が埋め込まれているはずです。その単語情報をデータとして別のファイルに保存し、プログラムとは分離してください。

データファイルのフォーマットは問いません。

どのようにしてデータファイルをプログラムに指定したり読み込ませたりするかの方法も問いません。

データファイルをどのようなフォーマットにしたか、どのようにデータファイルを指定するかはREADME.txtに記述してください。

#### 入力

  * データファイル
    * ファイル名は任意。例: dictionary-data.txt
    * 中身は「上手」という単語情報1つだけ。
    * データファイルはリポジトリーに入れること

データファイルは、例えば次のような内容：

    % cat dictionary-data.txt
    上手

#### 期待する結果

 * プログラムが実行されたら、なんらかの方法でデータファイルを読み込み、データファイル内にある「上手」という単語情報をロードして、その単語情報を出力する。
   
   実行例：
   
   ~~~
   % ./dictionary.sh dictionary-data.txt
   上手
   ~~~
   
 * グループの他の人がREADME.txtに従って、ファイルを作成してプログラムに単語情報をロードできる。


### 仕様4：データファイルに3つのデータを保存でき、出力できること

今のデータファイルには単語情報は「上手」1つだけしか登録されていません。これを、次の3つの単語情報を登録できるようにします。

  * 上手
  * 一時
  * 市場

また、プログラム実行時には登録されているすべての単語情報を出力してください。

単語情報のフォーマットは問いません。

どのようなフォーマットにしたかはREADME.txtに記述してください。

#### 入力

  * データファイル
    * ファイル名は任意。例: dictionary-data.txt
    * 中身は次の3つの単語情報。
      * 上手
      * 一時
      * 市場

データファイルは、例えばこういう内容です。

    % cat dictionary-data.txt
    上手
    一時
    市場

#### 期待する結果

 * プログラムが実行されたら、なんらかの方法でデータファイルを読み込んで、データファイル内にある3つの単語情報をロードし、すべての単語情報を出力する。
   
   実行例：
   
   ~~~
   % ./dictionary.sh dictionary-data.txt
   上手
   一時
   市場
   ~~~
   
 * グループの他の人がREADME.txtに従って、同様のデータファイルを作成できる。

### 仕様5：個々の単語にIDを振り出せること

今のプログラムは、同じ見出し語で読みが異なる単語を複数登録すると区別できません。登録された単語にプログラム内で自動でID（単語を一意に識別できる識別子）を振って単語を区別できるようにしてください。IDは数値でも文字列でも一意であればなんでも構いません。

出力するときはIDも出力してください。

#### 入力

  * データファイル
    * 中身は前の仕様と同じ次の3つの単語情報。
      * 上手
      * 一時
      * 市場

データファイルは、例えばこういう内容です。

    % cat dictionary-data.txt
    上手
    一時
    市場

#### 期待する結果

 * プログラムが実行されたら、読み込んだ単語情報になんらかの方法でIDを降り出し、すべての単語情報をID付きで出力する。
   
   実行例：
   
   ~~~
   % ./dictionary.sh dictionary-data.txt
   1: 上手
   2: 一時
   3: 市場
   ~~~

### 仕様6：IDが指定された場合はその単語だけ出力できること

今のプログラムは読み込んだ単語をすべて表示します。IDを指定した場合は指定したIDの単語だけを表示してください。

IDの指定方法は問いません。

IDの指定方法はREADME.txtに記述してください。

指定されるIDは必ず存在するIDと仮定してください。

IDを指定されなかった場合の挙動は変えないでください。

#### 入力

  * データファイル
    * 中身は前の仕様と同じ次の3つの単語情報。
      * 上手
      * 一時
      * 市場
  * 単語ID（省略可能）

#### 期待する結果

 * 単語情報のIDを伴ってプログラムが実行されたら、全ての単語情報を読み込み、その後、指定されたIDの単語情報のみを出力する。
   
   実行例：
   
   ~~~
   % ./dictionary.sh dictionary-data.txt 2
   2: 一時
   ~~~
   
 * 単語情報のIDを伴わずにプログラムが実行されたら、全ての単語情報を出力する。
   
   実行例：
   
   ~~~
   % ./dictionary.sh dictionary-data.txt
   1: 上手
   2: 一時
   3: 市場
   ~~~
   
 * グループの他の人がREADME.txtに従って、単語IDを指定できる。

### 仕様7：単語に読みがなを関連付けられること

今のプログラムは単語の見出し語しか情報を持っていません。それぞれの単語に読みがなを関連付けられるようにしてください。読みがなにはその単語の読みがなをひらがなで書きます。

出力時は、単語IDの指定の有無にかかわらず、見出し語と読みがなの両方を表示してください。

読みがなは長くても4KiBまでとします。

この条件を満たさない読みがなが指定されることはないと仮定して構いません。

データファイルのフォーマットは問いません。

どのようなフォーマットにしたかはREADME.txtに記述してください。

#### 入力

  * データファイル
    * ファイル名は任意。例: dictionary-data.txt
    * 中身は次の3つの単語情報。
      * 上手
      * 一時
      * 市場
    * それぞれに読みがなを関連付けること
  * 単語ID（省略可能）

データファイルは、例えばこういう内容です。

    % cat dictionary-data.txt
    上手 じょうず
    一時 いちじ
    市場 しじょう

#### 期待する結果

 * 単語IDの指定の有無に関わらず、プログラムが実行されたら、読みがな入りの全ての単語情報を読み込み、単語情報を出力する。
   
   実行例（単語IDの指定無しの場合）：
   
   ~~~
   % ./dictionary.sh dictionary-data.txt
   1: 上手 じょうず
   2: 一時 いちじ
   3: 市場 しじょう
   ~~~
   
 * グループの他の人がREADME.txtに従って、読みがなを関連付けたデータファイルを作成できる。

### 仕様8：単語に、単語を持っているユーザーの名前を関連付けて、出力できること

今のプログラムは単語情報の集まりをロードして出力するだけです。これに、だれが集めた単語情報かという情報を関連付けられるようにしてください。「だれ」のことを「ユーザー名」と呼ぶことにします。単語情報を出力するときは、単語IDの指定の有無にかかわらず、ユーザー名も出力してください。

ユーザー名に使える文字は次の通りとします。

  * 小文字のアルファベット
  * 数字
  * ハイフン
  * アンダーバー

ユーザー名は長くても10文字までとします。

この条件を満たさないユーザー名が使われることはないと仮定して構いません。

ユーザー名を関連付ける方法は問いません。

どのような方法でユーザー名を関連付ける仕様にしたかはREADME.txtに記述してください。

ユーザー名の出力方法は問いません。

#### 入力

  * データファイル
    * ファイル名は任意。例: dictionary-data.txt
    * 中身は次の3つの単語情報。
      * 上手
      * 一時
      * 市場
    * それぞれに読みがなを関連付けること
  * 単語に関連付けるユーザー名
  * 単語ID（省略可能）

データファイルは、例えばこういう内容です。

    % cat dictionary-data.txt
    上手 じょうず
    一時 いちじ
    市場 しじょう

#### 期待する結果

 * 単語IDの指定の有無に関わらず、プログラムが実行されたら、単語情報とそれに関連付くユーザー名を受け取り、ユーザー名と読み込んだ単語情報を出力する。
   
   実行例（単語IDの指定無しの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data.txt
   ユーザー名: kou
   1: 上手 じょうず
   2: 一時 いちじ
   3: 市場 しじょう
   ~~~
   
   実行例（単語IDの指定ありの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data.txt 2
   ユーザー名: kou
   2: 一時 いちじ
   ~~~
   
 * グループの他の人がREADME.txtに従って、単語情報にユーザー名を関連付けられる。

### 仕様9：4人のユーザーの単語情報に対応すること

今のプログラムは1人のユーザーの単語情報だけを扱えますが、これを4人のユーザーの単語情報も扱えるようにしてください。

出力するときはユーザー毎に単語を出力してください。

各ユーザー名とそのユーザーの単語情報の関連付けの方法は問いません。

どのような方法で各ユーザー名と単語情報を関連付ける仕様にしたかはREADME.txtに記述してください。

ユーザー名は重複するかもしれません（同名の別ユーザーが出現するかもしれません）。

プログラム実行時に単語IDが指定された場合の挙動は、前の仕様に準じます。
その際、IDを指定された単語に関連付けられていないユーザー名の出力をどう扱うかは問いません。

#### 入力

  * ユーザー名とデータファイルのペアを4つ
    * 各データファイル内の単語数は3つ
    * 1つはこれまで使ってきたデータファイルを使うこと
    * 残りの3つはこれまで使ってきたデータファイルを参考に新しく作ること
    * 異なるユーザーで同じ見出し語の単語情報を持っているかもしれない
      * 例：ユーザー1とユーザー2のどちらにも「上手」がある
    * すべての単語は異なるIDを持つこと
    * すべてのデータファイルはリポジトリーに入れること
  * 単語ID（省略可能）

データファイルは、例えば次のような内容です。

    % cat dictionary-data1.txt
    上手 じょうず
    一時 いちじ
    市場 しじょう

    % cat dictionary-data2.txt
    上手 うわて
    一時 いっとき
    市場 いちば

    % cat dictionary-data3.txt
    上手 かみて
    色紙 しきし
    寒気 さむけ

    % cat dictionary-data4.txt
    寒気 かんき
    色紙 いろがみ
    市場 しじょう

#### 期待する結果

 * 単語IDの指定の有無に関わらず、プログラムが実行されたら、各単語情報とそれに関連付くユーザー名を受け取り、ユーザー名と読み込んだ単語情報を出力する。
   
   実行例（単語IDの指定無しの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt kou dictionary-data4.txt
   ユーザー名: kou
   1: 上手 じょうず
   2: 一時 いちじ
   3: 市場 しじょう
   
   ユーザー名: piro
   4: 上手 うわて
   5: 一時 いっとき
   6: 市場 いちば
   
   ユーザー名: ashie
   7: 上手 かみて
   8: 色紙 しきし
   9: 寒気 さむけ
   
   ユーザー名: kou
   10: 寒気 かんき
   11: 色紙 いろがみ
   12: 市場 しじょう
   ~~~
   
   実行例（単語IDの指定ありの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt sunaot dictionary-data4.txt 5
   ユーザー名: kou
   
   ユーザー名: piro
   5: 一時 いっとき
   
   ユーザー名: ashie
   
   ユーザー名: kou
   ~~~
   
 * グループの他の人がREADME.txtに従って、各単語情報に各ユーザー名を関連付けられる。

### 仕様10：個々のユーザーにIDを振り出せること

今のプログラムは同じユーザー名だと区別できません。指定されたユーザーにプログラム内で自動でID（ユーザーを一意に識別できる識別子）を振ってユーザーを区別できるようにしてください。IDは数値でも文字列でも一意であればなんでも構いません。

出力するときはIDも出力してください。

プログラム実行時に単語IDが指定された場合の挙動は、前の仕様に準じます。

#### 入力

  * ユーザー名とデータファイルのペアを4つ
    * 各データファイル内の単語数は3つ
    * 1つはこれまで使ってきたデータファイルを使うこと
    * 残りの3つはこれまで使ってきたデータファイルを参考に新しく作ること
    * 異なるユーザーで同じ見出し語の単語情報を持っているかもしれない
      * 例：ユーザー1とユーザー2のどちらにも「上手」がある
    * すべての単語は異なるIDを持つこと
  * 単語ID（省略可能）

データファイルの内容は、前の仕様に準じます。

#### 期待する結果

 * 単語IDの指定の有無に関わらず、プログラムが実行されたら、読み込んだユーザーになんらかの方法でIDを降り出して、出力するユーザー名にそのIDを付与する。
   
   実行例（単語IDの指定無しの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt kou dictionary-data4.txt
   ユーザー: 1: kou
   1: 上手 じょうず
   2: 一時 いちじ
   3: 市場 しじょう
   
   ユーザー: 2: piro
   4: 上手 うわて
   5: 一時 いっとき
   6: 市場 いちば
   
   ユーザー: 3: ashie
   7: 上手 かみて
   8: 色紙 しきし
   91: 寒気 さむけ
   
   ユーザー: 4: kou
   10: 寒気 かんき
   11: 色紙 いろがみ
   12: 市場 しじょう
   ~~~
   
   実行例（単語IDの指定ありの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt sunaot dictionary-data4.txt 5
   ユーザー名: kou
   
   ユーザー名: piro
   5: 一時 いっとき
   
   ユーザー名: ashie
   
   ユーザー名: kou
   ~~~

### 仕様11：ユーザーIDが指定された場合はそのユーザーだけ出力できること

今のプログラムはすべてのユーザーを表示します。ユーザーIDが指定された場合はそのIDのユーザーだけを表示してください。

ユーザーIDの指定方法は問いません。

ユーザーIDの指定方法はREADME.txtに記述してください。

指定されるユーザーIDは必ず存在するものと仮定して構いません。

ユーザーIDが指定されなかった場合の挙動は変えないでください。

ユーザーIDと単語IDの両方が指定された場合は、該当ユーザーの該当単語情報だけ表示してください。単語IDは、指定されたユーザーが持っている単語のIDであると仮定して構いません。

#### 入力

  * ユーザー名とデータファイルのペアを4つ
    * 各データファイル内の単語数は3つ
    * 1つはこれまで使ってきたデータファイルを使うこと
    * 残りの3つはこれまで使ってきたデータファイルを参考に新しく作ること
    * 異なるユーザーで同じ見出し語の単語情報を持っているかもしれない
      * 例：ユーザー1とユーザー2のどちらにも「上手」がある
    * すべての単語は異なるIDを持つこと
  * ユーザーID（省略可能）
  * 単語ID（省略可能）

データファイルの内容は、前の仕様に準じます。

#### 期待する結果

 * プログラムが実行されたら、各ユーザー名とそれぞれに対応する単語情報を読み込むみ、その後、指定されたIDのユーザーの単語情報のみを出力する。
   
   実行例（単語IDの指定無しの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt kou dictionary-data4.txt 4
   ユーザー: 4: kou
   10: 寒気 かんき
   11: 色紙 いろがみ
   12: 市場 しじょう
   ~~~
   
   実行例（単語IDの指定ありの場合）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt kou dictionary-data4.txt 4 11
   ユーザー: 4: kou
   11: 色紙 いろがみ
   ~~~
   
   実行例（単語IDの指定あり、ユーザーIDの指定無しの場合：ここではユーザーIDに`-1`を指定したら指定無しと扱うものと仮定）：
   
   ~~~
   % ./dictionary.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt kou dictionary-data4.txt -1 11
   ユーザー: 1: kou
   
   ユーザー: 2: piro
   
   ユーザー: 3: ashie
   
   ユーザー: 4: kou
   11: 色紙 いろがみ
   ~~~
   
 * グループの他の人がREADME.txtに従って、ユーザーIDを指定できる。

### 仕様12: 主要機能がライブラリーとして分離されていること

ユーザー・辞書管理部分をライブラリーとして分離し、複数のプログラムから再利用できるようにしてください。これまでの挙動をするプログラムは、この分離したライブラリーを使うアプリケーションとしてください。すべての挙動は変えないでください。

次の入出力部分はライブラリーではなく、アプリケーションプログラム側に入れてください。

  * このプログラムの利用者からユーザー名や単語情報などの入力を受け取る部分
  * データファイルを読み込む部分
  * 結果を出力する部分

プログラムをビルドする方法や実行方法が変わった場合はREADME.txtを更新してください。

#### 入力

仕様11に準じます。

#### 期待する結果

仕様11に準じます。

### 仕様13: 出力フォーマットがCSVである、別のプログラムを作ること

ライブラリーを使用して、結果をCSVで出力する別のプログラムを作ってください。

出力フィールドは左から順に次のとおりにしてください。

  * ユーザーID
  * ユーザー名
  * 単語ID
  * 見出し語
  * 読みがな

README.txtに実行方法を追記してください。

#### 入力

仕様11に準じます。

#### 期待する結果

 * プログラムが実行されたら、各ユーザー名とそれぞれに対応する単語情報を受け取り、ユーザー名と対応する単語情報をCSV形式で出力する。
   
   実行例（ユーザーID、単語IDの指定無しの場合）：
   
   ~~~
   % ./dictionary-csv.sh kou dictionary-data1.txt piro dictionary-data2.txt ashie dictionary-data3.txt kou dictionary-data4.txt
   1,kou,1,上手,じょうず
   1,kou,2,一時,いちじ
   1,kou,3,市場,しじょう
   2,piro,4,上手,うわて
   2,piro,5,一時,いっとき
   2,piro,6,市場,いちば
   3,ashie,7,上手,かみて
   3,ashie,8,色紙,しきし
   3,ashie,9,寒気,さむけ
   4,kou,10,寒気,かんき
   4,ashie,11,色紙,いろがみ
   4,kou,12,市場,しじょう
   ~~~
   
 * グループの他の人がREADME.txtに従って、プログラムを実行できる。

### 仕様14: シークレット

チューターに仕様を聞いてください。

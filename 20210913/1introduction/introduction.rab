= 概要

: author
   結城洋志
: institution
   株式会社クリアコード
: content-source
   リーダブルコード演習
: date
   2021-09-13
: allotted-time
   60m
: theme
   clear-code

= 全体の流れ

  * 1日目（本日）
    * 前半：概要と進め方の説明
    * 後半：チームで実装
  * 2日目（明日）
    * 前半：チーム同士で実装を交換、\n
      　　　続きを実装
    * 後半：全体で結果を共有

== ノート

まず最初に、全体の大まかな予定を示すが、ここはサッと流す。
進行の進行度合いによっては、実装作業の時間を長めに取る可能性があることを伝える。


= 講師紹介

(('tag:center'))(('tag:margin-bottom * 2'))
結城洋志（ゆうき ひろし）

  * 株式会社クリアコード所属
  * FirefoxやThunderbirdの\n
    法人サポートに従事
    * トラブルの原因や対策を探るため\n
      ソースコードを調査することが多い
  * Firefox/Thunderbird用の\n
    アドオンを公私で開発

== ノート

Mozilla FirefoxはWebブラウザー。
Mozilla Thunderbirdはメールクライアント。

開発元のMozillaは、企業ユーザーからのトラブル問い合わせなどに回答するサービスは提供していない。
そのため、クリアコードのような事業者が、ある意味で勝手にサポートサービスを行っている。
クリアコードは10人未満の小規模事業者で、エンドユーザーからの電話問い合わせに対応するといったビジネスはできないので、そうではなく、企業の情報システム担当者や、大学であればシステム管理者といったレベルの方が、ある程度までは自分達で対応した上で、それでもまだ分からないことを問い合わせる（エスカレーションする）先としてテクニカルサポートを提供している。

FirefoxもThunderbirdも、自分達が作っている物ではないし、作っている人達は企業ユーザーの実際の利用の仕方を知らないので、企業ユーザー向けの技術資料といった物も特にない。
よって、問い合わせを受ける度にソースコードを読んで調査することになる。
「リーダブルなコード」の恩恵を非常に強く受ける立場だと言える。

= チューター紹介

(('tag:center'))(('tag:margin-bottom * 2'))
XXXXXX（XXX XXXX）

  * XXXXXXX
  * 参加者のサポート係

== ノート

簡単に背景を説明する。

= アジェンダ

  * ((*講座の目的*))を確認
  * リーダブルコードの\n
    ((*必要性*))を確認
  * リーダブルコードの\n
    ((*実践方法*))を紹介
  * 実践方法を((*練習*))

== ノート

サッと流す。


= 講座の目的

  * ((*リーダブルコード*))を\n
    ((*日常的に書く*))上での\n
    ((*基礎となる考え方*))\n
    を実践し、持ち帰る

== ノート

サッと流す。

= 目的でないこと

  * テクニックをたくさん覚える
  * 難しいプログラムを実装する
  * プログラムを速く実装する
  * 高性能なプログラムを実装する
  * 奇抜な方法で目立つ

== ノート

サッと流す。

= 　

= そもそもの話

  * リーダブルコードはなぜ必要か
  * 何の役に立つのか？

(('note:みんなはどう思う？'))

== ノート

2人くらい受講者の人の意見を聞いてみる。

= リーダブルコードが必要な理由

  * 既存のコードを読んで\n
    ((*素早く内容を把握する*))ため

== ノート

サッと流す。

= 素早く内容を把握できないといけない理由

  * 既存のコードに\n
    ((*手を加える・続きを書く*))ときの\n
    効率を落とさないため
  * ((*開発速度*))を落とさないため

== ノート

サッと流す。

= 「速度」？

  * 「読みやすさに気をつけたら\n
    　開発スピードが落ちそう」

(('note:みんなはどう思う？'))

== ノート

サッと流す。

= むしろ「読みにくいと開発が遅くなる」

  * 既存のコードを理解しにくいと\n
    変更のコストが高くなる
  * 変更のコストが高いと……
    * 修正・機能追加に時間がかかる\n
      (('note:（理解しないと変更できない）'))
    * 後退バグが発生しやすい\n
      (('note:（理解しないまま変更すると問題発生）'))

== ノート

サッと流す。

= 時間が経つほど影響大

  # image
  # src = images/readable-code-reasonability.svg
  # relative_width = 90

(('tag:center'))
(('note:（注意：グラフではなく概念図です）'))

== プロパティー

: enable-title-on-image
   false

== ノート

グラフ風の図
グラフの縦軸は開発スピードで、上に行くほど爆速、下に行くほど停滞。
グラフの横軸は時間経過。

読みやすさを考えずにコードを書き散らかすと、最初のうちは開発速度が爆速だけれども、時間経過に伴って、やがて急速に開発スピードが落ちて、進捗が悪くなってくる。
読みやすさを考えながらコードを書くと、慣れないうちは平均的に少し開発速度が遅くなるけど、時間が経過しても、開発スピードが落ちにくく、進捗も悪くなりにくい。

これはいろんな人が言っている。
「読みやすさ」よりもう少し広く「内部品質の高さ」「保守性の高さ」という切り口の話になるけれど、「保守性を犠牲にして開発する場合と、保守性を高く保って開発する場合に、曲線が交差する点（つまり損益分岐点）には1ヵ月くらいで到達する」と言われている。

1ヵ月という数字の出典：
質とスピード（2020秋100分拡大版） / Quality and Speed 2020 Autumn Edition
https://speakerdeck.com/twada/quality-and-speed-2020-autumn-edition

この事実を無視して、読みにくいコードのままで開発を続けながら〆切を守ろうとすると、徹夜や連勤といったことになって、自分の命を削ることになる。
あるいは、増員をするために人件費が増える。

= リーダブルコードの必要性

  * 現実的なコストの範囲で
  * 既存のコードを継続的に、\n
    無理なく改良・修正したい

== ノート

ここはサッと流す。

= 既存のコードに手を加える場面

(('note:在学中だとどんな場面がありそう？'))

== ノート

2人くらい受講者の人の意見を聞いてみる。

= 既存のコードに手を加える場面

  * ((*複数人*))で研究
    * 共同研究、院生と学部生で分担
  * 自分の研究を((*発展*))
    * 修士で作った物を博士で使う
    * 途中で((*方針修正・転換*))
  * 先輩の研究を((*参照*))

== ノート

受講者から出てこなかった物について述べる。

= コードを読む場面

(('note:在学中だとどんな場面がありそう？'))

== ノート

2人くらい受講者の人の意見を聞いてみる。

= コードを読む場面

  * ((*論文に含まれるコード*))\n
    を読むとき
    * 自分が誰かの論文を読むとき
    * 自分の論文が誰かに読まれるとき

(('note:コードがリーダブルだと参照されやすくなるかも……'))

== ノート

受講者から出てこなかった物について述べる。


= 営利企業ではどうか

  * チーム開発が多い
    * 分かる人が1人しかいない→危険
      * 実装者がいなくなったら変更できない
      * 質問もできない
      * 変更できてもコストが大きい

(('wait'))
(('tag:center'))
↓\n
チームの誰でも\n
既存コードを理解できる\n
状態にしておく必要がある

== ノート

ファミコン時代（30年くらい前）には「たった一人のスーパープログラマーが、常人には理解不能な黒魔術的なテクニックを駆使して、ハードウェア性能を限界まで引き出して物凄い演出を実現する」事例が度々あった。
そういうケースでは、そのスーパープログラマーがいなくなってしまった後に、新しいゲーム機向けに移植しようとしても、当時のプログラムを誰も理解できなくて、移植が実質的に不可能になってしまっていたり（アクションゲームだと、移植作の挙動がオリジナル版とまったく異なってしまっていて、ゲーム性が損なわれたという例もある）、移植にとんでもないコストがかかってしまったり、という事が起こった。
それは極端なケースだけれど、ビジネスが個人に強く依存することは、企業にとってはリスクなので、基本的には避けたいことだと言える。


= リーダブルコードの目的

  * 既存のコードの\n
    ((*内容を把握する*))コスト
  * 既存のコードを\n
    ((*適切に変更する*))コスト

を少なくするため

== ノート

ここまでの小まとめ。

IT関係、特にプログラミングの書籍は賞味期限が非常に短いことが多い。
しかし、書籍「リーダブルコード」は2012年の発売から10年近くが立つのに、今でもベストセラーの上位に食い込んでいて、多くのベテランが「読むべき本」として名前を挙げ続けている。
それは何故かと言えば、リーダブルなコードは、保守性の高いソフトウェアの書き方の基礎だから。
将来的には、より保守性の高い設計の仕方を身に着けていくことが望ましいけれど、それは追々やっていこう。
最初のステップとして、まず「読みやすい」コードにすることを意識するところから始めよう。


= 　


= リーダブルコードの実践

(('note:どうすれば無理なく実践できる？'))

== ノート

2人くらい受講者の人の意見を聞いてみる。

= リーダブルコードの実践

コードを((*読む*))\n
習慣を作る

= 読む？書くじゃないの？

  * リーダブルコードを書くには\n
    コードを読んだ方がいい
    * なぜ？

(('wait'))
(('tag:center'))
↓\n
書いている最中は\n
((*読みやすさ・読みにくさ*))\n
を実感しにくいから

= コードを書いてる最中は、意外と読んでない

  * ((*脳内にあるイメージ*))\n
    ((*＋目の前にあるコード*))\n
    で認識している
  * 脳が無意識に補完するので、\n
    読みにくさに気付けない

= 実際のコードで考えてみる

  * Excelワークシートの生成で\n
    見出しセルを結合する関数

  # image
  # src = images/xlsx.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

== ノート

（自己紹介で触れた場合）自分は業務でFirefoxの法人運用のサポートをしている。
このExcelワークシートは、「Firefoxの自動更新」という設定項目に対して、選択肢が「1. 自動更新します」「2. 自動更新を停止します」の2つがある、といった要領で、企業での運用でよく求められるカスタマイズ内容とその設定方法を表にした物。お客さん向けの資料。

カスタマイズ項目の情報は、Gitで管理しやすいようにテキストファイルを原本としている。
それを元に、プログラムで自動的にExcelワークシートを作るようにしている。
ということを踏まえて、どうやってこれを作るかということを考える。


= 頭の中にあるイメージ

    関数 項目の見出し列（B～C）のセルを結合する(行番号, 項目):
        項目の選択肢の数が1以下だったら:
            何もせず終了
        そうでないなら（選択肢が2つ以上あるなら）、
        「見出し列の定義の配列」の全要素について、 要素の番号 を使って:
            シートの範囲を結合(
              開始行 → 行番号,
                開始列 → 要素の番号,
              終了行 → 行番号 + 選択肢の数 - 1,
                終了列 → 要素の番号) 

== ノート

これだけを見ても分からないと思われるので、ここからは表と擬似コードを並べて説明する。

= 見出し列？

  # image
  # src = images/xlsx-01.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

== ノート

「見出し列」というのは、この図で赤く囲った部分。

= セルを結合？

  # image
  # src = images/xlsx-02.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

== ノート

「セルを結合」というのは、この図で赤く囲った部分のこと。
この図では3行分が結合されている。

= 見出し列の定義の配列？

  # image
  # src = images/xlsx-03.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

== ノート

「見出し列の定義の配列」というのは、図の右上に示したような物が別途定義されているイメージ。
この配列の要素がそれぞれB列とC列に対応している。

= 行と列の番号で範囲指定？

  # image
  # src = images/xlsx-04.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

== ノート

「シートの範囲を結合」という部分で、行番号と列番号を使って範囲を指定し、セルを結合する。
これは、ライブラリがそのようなAPIを提供している。

ここまでの話を頭に入れた上で、そのような目的を達成するために実際にコードを書いたらどうなるだろうか。


= 実際のコードがこうだったら？

    def m(s, n, i):
        if len(i['o']) <= 1:
            return
        s2 = s._s
        for i2, _ in enumerate(hcol):
            s2.merge_range(n, i2,
                           n + len(i['o']) - 1, i2,
                           '')

== ノート

これは敢えて「リーダブルでない」書き方にした物。
Pythonだと思って読んで欲しい。
変数名は短くて、名前に意味は無い。
さっきの「頭の中にあるイメージ」と照らし合わせれば、なんとか意味を読み取れるかもしれない。


= 前提知識無しで読んだ結果

    関数 何か(何か, 何か, 何か):
        何かの数が1以下だったら:
            何もせず終了
        そうでないなら、
        何か = 何かが保持している何か
        何かについて、 何か を使って:
            何かの範囲を結合(
              何か, 何か,
              何か + 何か - 1, 何か)

(('note:意味ある情報を読み取るのは困難……'))

== ノート

さっきの「頭の中にあるイメージ」を共有していない人が見ると、読んでもこの程度のことしか分からない。
コードを後から引き継いだ人が読んだときや、コードを書いた本人でも1年後に読み返したときだと、この程度の情報しか読み取れない。
こういう状態で「不具合を直す」「壊さないように改修する」というのは非常に難しい。
プロでも厳しい。


= リーダブルなコード

    def try_merge_item_heading(self, row, item):
        if len(item['options']) <= 1:
            return
        sheet = self._sheet
        for index, _column in enumerate(HEADING_COLUMNS):
            sheet.merge_range(row,
                                index,
                              row + len(item['options']) - 1,
                                index,
                              '')

= 読んだ結果

    関数 項目の見出しセルを結合する(自分, 行, 項目):
        項目の選択肢の数が1以下だったら:
            何もせず終了
        そうでないなら、
        シートは自分が保持している
        見出しの列の全項目について、 番号 を使って:
            シートの範囲を結合(
              行, 番号,
              行 + 項目の選択肢の数 - 1, 番号,
              '')

(('note:先の例よりは意味のある情報を読み取れるはず'))

= よく聞く話

  * 手紙を書いたら一晩寝かせろ！
  * 試験の回答文は、最後に\n
    もう一回読み返せ！

(('wait'))
(('tag:center'))
↓\n
脳内補正が働かなくなった状態で\n
改めて素直に読むと\n
粗に気付きやすい

= 実際のコードを読んでみよう

Excelのワークシートを\n
自動生成するPythonスクリプト

  # image
  # src = images/xlsx.png
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

= 作られた経緯

  * 設定の管理のための\n
    Excelワークシートを手作り
  * Gitでバージョン管理しにくい
    * プレーンテキスト形式のソースから\n
      Excelワークシートを自動生成すれば\n
      いいのでは？
  * 初版はPythonに慣れた人が実装

= 読んでみよう1

build-xlsx-((*1*)).py\n
(('note:10分くらいで概要を掴んでみよう'))

= ポイント

  * 少数の短い関数
  * 変数名は短め
  * 列番号はべた書きで充分

= 試しに探してみよう1

  * 「...→...での変更」の列に\n
    「新規」と出力する条件は\n
    どこで判定している？

= 試しに読んでみよう2

build-xlsx-((*2*)).py\n
(('note:第三者が手を加えた物'))

= 改修の経緯

  * 要件が増えた（問題が複雑化した）
    * 列の数が可変になった
    * 色分けの条件が増えた
  * Python素人が見よう見まねで改修
  * 行数は約1.2倍に増加

= 試しに探してみよう2

  * 「検証手順書対応番号」\n
    の列に出力する内容は\n
    どこで決めている？

(('note:かなり大変なはず'))

= リーダブルだった書き方がアンリーダブルに

  * 関数の数が少ない
    * 関数が肥大化し全体像の把握が困難
  * 変数名が短い
    * 変数の数が増えてくると混乱の元に
  * 列番号が直書きされている
    * 列が増減する度に連鎖的に変更発生\n
      (('note:読みやすさだけでなく、変更コストの増大も問題'))

= 試しに読んでみよう3

build-xlsx-((*3*)).py\n
(('note:大幅に改修した物'))

= 改修の内容

  * クラスを導入
  * 複雑化した問題に合わせて「リーダブル」の基準を変えた\n
    (('note:何がリーダブルかは状況に依存する'))
    * 数字の決め打ちを減らす
    * メソッド・変数のスコープを小さく
  * コードの行数は約1.5倍に増加

= 試しに探してみよう3

  * 「検証済み」という列を\n
    「検証手順書対応番号」\n
    の列の右隣に追加したい\n
    （セルの内容は空でよい）が、\n
    どこに手を入れればいい？

(('note:探し方のコツを掴むと案外スルッと見つけられるはず'))

= 探し方のコツ

  * 改修前：\n
    ((*全体*))を読んで覚えて探す
  * 改修後：\n
    ((*必要な部分だけ*))読んで探す

= ふつうのOSS開発者の日常

  * ((*× イメージ*))
    * コード全体を詳細・完璧に把握
    * ノールックで修正
  * ((*◯ 実態*))
    * 全体像はボンヤリ把握
    * 都度必要な部分を読み直して\n
      調べ直しながら修正

= 自分で書いたコードでも、覚えてないのが当たり前！

  * ((*覚えておかなくていいように*))\n
    ((*する*))のがリーダブルコード
  * 書籍「リーダブルコード」\n
    巻末の「解説」も読んでみて！


= 　

= リーダブルコードの実践

  * 別の切り口でも考えてみよう
  * なぜ((*アンリーダブル化する*))\n
    のか？

= アンリーダブル化の予防

  * リーダブルだった物でも\n
    ((*アンリーダブル化*))してしまう
  * ((*どういうとき*))に\n
    そうなってしまうのか？

= アンリーダブル化する原因

(('note:考えてみよう'))

= アンリーダブル化する原因1

  * コードが((*状況の変化*))に\n
    追従できていない
    * 問題の規模や前提の変化
    * 書く人の熟練 (('note:など'))

= 状況の変化に追従できない原因

  * 既存のコードを((*書き直さない*))
    * 「書き足す」一方になっている
    * 書き直して動かなくなるのが怖い
      * 言語やライブラリに不慣れ
    * とりあえず動く状態にしようと\n
      焦っている
      * 冷静に見直す余裕がない

= ベテランはどうしている？

  * 既存のコードを\n
    ((*書き直すのをためらわない*))
    * 書き直さない方が、\n
      ((*後で痛い目を見る*))と知っている

= ためらわずに書き直せるのは何故？

  * わけが分からないままにしない
    * ((*自分が今何をしているか*))を\n
      正しく理解するよう努めてる
    * 不安が少しでも生じたら\n
      立ち止まって考える

= ためらわずに書き直せるのは何故？

  * 便利な道具で補う
    * 自動テストで((*結果の同値性*))を保証\n
      (('note:自動テストは大事！'))
    * Gitで((*いつでも巻き戻せる*))安心感\n
      (('note:バージョン管理システムは大事！'))
    * ((*コードフォーマッター*))で\n
      安全にコードを整形\n
      (('note:「リーダブルにする」はある程度自動化できる'))

= アンリーダブル化する原因2

  * そもそも\n
    解決しやすい問題でない
    * プログラム的に実現しにくい
      * ((*情報の登場順と逆順*))の依存関係
      * 再帰/繰り返しに見えて、((*少しだけ違う*)) (('note:など'))
    * 問題の再設定が許されていない
      * 「プレーンテキスト形式は駄目。\n
        　必ずExcel形式で。」

= ベテランはどうしている？

  * 簡単に解ける部分と\n
    解くのが((*本質的に困難*))な部分\n
    に((*問題を分割*))する
    * 簡単に解ける部分を切り分けていくと\n
      解くのが困難な部分が残る

= 権力を手に入れると楽になる

  * ((*問題の設定*))から関わる
    * ゴール設定を人任せにしない
    * 必要な権限を持つ

= ベテランも特別なテクニックは使っていない

  * 「アンリーダブルに\n
    　なり始めてる……？」\n
    →((*即座に*))書き直す\n
    (('note:後回しにしない！'))
  * ((*マメに読み返している*))と、\n
    アンリーダブルのなり始めに\n
    すぐ気付ける


= ベテランを真似よう

  * マメに((*書き直し続ける*))
    * 「動いた」はスタート地点
  * 書き直しを避けて通らない
    * 自分のしてることを((*正確に理解*))
    * 自動テストやGitで((*恐怖を克服*))
  * コードの規模に応じて\n
    ((*基準を見直し続ける*))
    * 絶対のゴールは存在しない


= 　

= リーダブルコードの練習

  * この講義の演習時間で\n
    何をすればリーダブルコードを\n
    実践できるか？

= やりたいこと

  * なるべく脳内補正を外して\n
    コードを読む/コードを書く\n
    のサイクルを体験したい

= そのためのチーム開発

  * チームメンバーごとに\n
    何がリーダブルかの基準は違う
    * 背景が違うので当たり前\n
      (('note:（背景：使ってきた言語・今の知識）'))
  * まずは、チームの中で\n
    コードを読みあってみる\n
    (('note:（自分で書いた物を読むよりは客観的に読みやすい）'))
    * 交代で書く / 感想を述べ合う

= 注意点

  * なるべくポジティブな提案を
    * ◯「この書き方はリーダブルだね」
    * ×「これはアンリーダブルだね」\n
      (('note:（粗をあげつらうだけなら誰でもできる）'))
      * ◯「こうした方がリーダブルじゃない？」
  * チーム内で皆が納得できる\n
    リーダブルの基準を見つけよう
    * 既存の基準をベースにするのはアリ\n
      (('note:（基準：書籍「リーダブルコード」の内容など）'))

= 明日の後半戦

  * （進捗次第では、\n
    　今日の後半の続きをやる）

= 明日の後半戦

  * 他のチームが\n
    書いたコードを読んでみる\n
    (('note:（自分のチームの物を読むよりは客観的に読みやすい）'))
    * チーム間で感想を共有
    * より多くの人が納得できる\n
      リーダブルの基準を見つけよう
  * 開発を継続してみる

= 最終目標：コードを読む文化を持ち帰ろう

  * 「コードは読む物」\n
    という認識を持つ
  * 自分だけからチームへ
  * チームだけから全体へ

= この後の予定まとめ

  * 本日の後半：課題を実装
    * リーダブルコードを書く体験
  * 明日の前半：実装チェンジ\n
    　　　　　　→開発継続
    * 既存のコードを読んで変更する体験
  * 明日の後半：ふりかえり
    * リーダブルコードの基準を\n
      共有する体験

= おさらい

  * 講座の目的？
  * リーダブルコードの必要性？
  * 講座でやること？

= 講座の目的

  * ((*リーダブルコード*))を\n
    ((*日常的に書く*))上での\n
    ((*基礎となる考え方*))\n
    を実践し、持ち帰る

= リーダブルコードの必要性

  * 既存のコードを読んで\n
    ((*素早く内容を把握する*))ため
  * 既存のコードに\n
    ((*手を加える・続きを書く*))ときの\n
    効率を落とさないため

= 変更コストと開発速度

  # image
  # src = images/readable-code-reasonability.svg
  # relative_width = 90

== プロパティー

: enable-title-on-image
   false

= 講座でやること

  * コードを読む文化作りの体験
    * チームの中でコードを\n
      読みあってみる
    * チーム内でリーダブルコードの\n
      基準を共有する
    * 他のチームともリーダブルコードの\n
      基準を共有する

= ここまでの説明

腑に落ちましたか？
